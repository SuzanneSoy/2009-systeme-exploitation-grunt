#include <module.h>
#include <types.h>
#include <string.h>

#include <tri/tas/tas.h>
#include <demarrage/multiboot/multiboot.h>
#include <interfaceUtilisateur/console/console.h>
#include <recherche/dichotomique/dichotomique.h>

MODULE(Multiboot);

DEPENDANCE_MODULE(Multiboot, Console);

/* __listeModule et __finListeModules sont définis dans modules/creerImage.lds */

extern InfoModule __listeModules;
extern InfoModule __finListeModules;

extern DependanceModule __listeDependancesModules;
extern DependanceModule __finListeDependancesModules;


void afficherNomModule(InfoModule* module) {
	CouleurAvAr ancienneCouleur = consoleCouleur(0x00ff00ff, 0);
	afficherChaineZ(module->nom);
	afficherChaineZ("\n");
	consoleCouleur(ancienneCouleur.av, ancienneCouleur.ar);
}

void afficherNomsModulesManques(InfoModule* listeModules) {
	// effacerConsole(); /* Seulement en mode texte, en mode graphique, l'écran est déjà noir... */
	InfoModule* module = listeModules;
	
	while (module != NULL) {
		if (module->etapeChargementModule == ETAPE_MODULE_INITIALISE)
			afficherNomModule(module);
		module = module->suivant;
	}
}


void* triDependancesGet(void* t, uint32 index) {
	return ((DependanceModule*)t) + index;
}

void triDependancesEchange(void* t, uint32 a, uint32 b) {
	DependanceModule* tt = t;
	DependanceModule c;
	
	c = tt[a];
	tt[a] = tt[b];
	tt[b] = c;
}

int triDependancesCmp(void* a, void* b) {
	void* aa = ((DependanceModule*)a)->module;
	void* bb = ((DependanceModule*)b)->module;
	
	if (aa < bb)
		return -1;
	else if (aa == bb)
		return 0;
	else
		return 1;
}

void pointEntreeNoyau(void* addrInfoMultiboot, uint32 magicMultiboot) {
	asm volatile ("cli");
	
	int nbModules = 0;
	InfoModule* module;
	InfoModule* moduleTemp;
	InfoModule* listeModules = &__listeModules;
	InfoModule* finListeModules = &__finListeModules;
	
	int i;
	int nbDependancesModules;
	int premiereDependanceModule;
	int derniereDependanceModule;
	DependanceModule dependanceRecherchee;
	DependanceModule* dependanceModule;
	DependanceModule* listeDependancesModules = &__listeDependancesModules;
	DependanceModule* finListeDependancesModules = &__finListeDependancesModules;
	
	/* Pré-initialisation de l'état du module multiboot */
	etatMultiboot->InfoMultiboot = addrInfoMultiboot;
	etatMultiboot->magicMultiboot = magicMultiboot;
	
	
	/* Tri de la liste de dépendances */
	nbDependancesModules = ((int)finListeDependancesModules - (int)listeDependancesModules) / sizeof(DependanceModule);
	triParTas(
		listeDependancesModules,
		nbDependancesModules,
		triDependancesGet,
		triDependancesEchange,
		triDependancesCmp
	);
	
	/* Chaînage des modules */
	nbModules = ((int)finListeModules - (int)listeModules) / sizeof(InfoModule);
	module = listeModules;
	while (module < finListeModules) {
		module->suivant = module + 1;
		
		dependanceRecherchee = (DependanceModule){ module, NULL };
		premiereDependanceModule = rechercheDichotomiquePremier(
			&dependanceRecherchee,
			listeDependancesModules,
			nbDependancesModules,
			triDependancesGet,
			triDependancesCmp
		);
		
		if (premiereDependanceModule < 0) {
			module->dependances = NULL;
			module->nbDependances = -1;
		} else {
			derniereDependanceModule = rechercheDichotomiqueDernier(
				&dependanceRecherchee,
				listeDependancesModules,
				nbDependancesModules,
				triDependancesGet,
				triDependancesCmp
			);
			module->dependances = listeDependancesModules + premiereDependanceModule;
			module->nbDependances = derniereDependanceModule - premiereDependanceModule + 1;
		}
		
		module++;
	}
	if (nbModules != 0)
		(module-1)->suivant = NULL;
	
	
	/* Initialisation des modules */
	module = (nbModules != 0) ? listeModules : NULL;
	bool consoleDisponible = FALSE;
	/* GCC BUG :
	 * 
	 *   while ((void*)module != (void*)NULL) {
	 *       ...
	 *   }
	 * 
	 * Lorsqu'on regarde la sortie assembleur de GCC, on voit qu'il teste
	 * avant l'entrée dans la boucle s'il doit l'éviter, après quoi aucune
	 * instruction ne permet d'en sortir. Ce qui explique le fonctionnement
	 * incorrect du programme à l'exécution. De plus, on se rend compte
	 * avec des comparaisons ( < , = , > ) qu'il semble considérer que
	 * 1 < module < 2 (donc on a un pointeur flottant \o/ ). Vu qu'il y a
	 * très peu de chances pour que l'info sur un module soit située à 1 (!),
	 * on utilise ((void*)module > (void*)(1)) . */
	
	while ((void*)module > (void*)(1)) {
		if (module->etapeChargementModule != ETAPE_MODULE_INITIALISE) {
			dependanceModule = module->dependances;
			
			for (i = 0; i < module->nbDependances; i++) {
				if (dependanceModule->dependance->etapeChargementModule != ETAPE_MODULE_INITIALISE) {
					dependanceModule->dependance->suivantRecursionDependances = module;
					module = dependanceModule->dependance;
					goto finBoucleInitialisationModules;
				}
				dependanceModule++;
			}
			
			
			if (consoleDisponible)
				afficherNomModule(module);
			
			
			(*(module->init)) (module->etat);
			module->etapeChargementModule = ETAPE_MODULE_INITIALISE;
			
			if (!consoleDisponible && consolePrete()) {
				consoleDisponible = TRUE;
				afficherNomsModulesManques(listeModules);
			}
		}
		
		
		if (module->suivantRecursionDependances != NULL) {
			moduleTemp = module->suivantRecursionDependances;
			module->suivantRecursionDependances = NULL;
			module = moduleTemp;
		} else {
			module = module->suivant;
		}
		
		finBoucleInitialisationModules:
		{} /* Fausse instruction pour éviter un "error: label at end of compound statement" */
	}
	
	
	/* Fin */
	afficherChaineZ("\n\n");
	
	for (;;) asm volatile ("hlt;");
}


void initMultiboot(void** etat) {
	*etat = etatMultiboot;
	
	/* if (etatMultiboot->InfoMultiboot->flags.bootLoaderName) {
		afficherChaineZ("Charg" STR_eacute " par ");
		afficherChaineZ(etatMultiboot->InfoMultiboot->bootLoaderName);
		afficherChaineZ(".\n");
	} */
}

void deinitMultiboot(void** etat) {
	*etat = NULL;
}

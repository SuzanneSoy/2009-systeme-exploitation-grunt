#ifndef DEMARRAGE_MULTIBOOT_MULTIBOOT_H
#define DEMARRAGE_MULTIBOOT_MULTIBOOT_H

#include <types.h>

/**
 * @brief  Informations récupérées par grub
 * 
 * D'abord les sous-structures, puis la structure principale.
 */

/* FIXME : De quoi s'agit-il réellement ? */
typedef uint32 pointeurLointain;

/**
 * @brief  Disponibilité des informations.
 */
typedef struct MultibootInfoFlags {
    bool mem:1;
    bool bootDevice:1;
    bool cmdline:1;
    bool mods:1;
    bool aout:1;
    bool elf:1;
    bool mmap:1;
    bool drives:1;
    bool configTable:1;
    bool bootLoaderName:1;
    bool apmTable:1;
    bool vbe:1;
    uint32 PADDING:20;
} PACKED MultibootInfoFlags;

/**
 * @brief Média de stockage utilisé lors du démarrage.
 */
typedef struct MultibootInfoBootDevice {
    uint8 part1;
    uint8 part2;
    uint8 part3;
    uint8 drive;
} PACKED MultibootInfoBootDevice;

/**
 * @brief Modules chargés par le chargeur de démarrage.
 */
typedef struct MultibootInfoModule {
    void* modStart;
    void* modEnd;
    
    StringZ string;
    
    uint32 reserved;
} PACKED MultibootInfoModule;

/**
 * @brief Table des symboles a.out .
 */
typedef struct MultibootInfoAout {
    uint32 aoutTabSize;
    uint32 aoutStrSize;
    
    /* le type de aoutAddr devrait être nlist (cf. standard
     * multiboot), mais de quoi s'agit-t-il ? */
    void* aoutAddr;
    
    uint32 reserved;
} PACKED MultibootInfoAout;

/**
 * @brief Table des en-têtes de section pour ELF.
 */
typedef struct MultibootInfoElf {
    uint32 num;
    uint32 size;
    
    void* addr;
    
    StringZ* shndx; /* Tableau de StringZ ou de String ? */
} PACKED MultibootInfoElf;

/**
 * @brief Cartographie de la mémoire.
 * 
 * Si type != MultibootInfoMmapRam alors cette mémoire est réservée
 * (mémoire vidéo, etc.)
 */
#define MultibootInfoMmapRam = 1;
typedef struct MultibootInfoMmap {
    /* Attention, mmapAddr tel que fourni par grub pointe sur le 2e
     * champ (baseAddr), il faut donc enlever 4 octets à
     * l'adresse. */
    uint32 size;
    
    /* Avec 32_low suivi de 32_high, je peux en faire 64. Ne me
     * seais-je pas trompé dans l'endianisme ? */
    uint64 baseAddr;
    uint64 length;
    uint32 type;
} PACKED MultibootInfoMmap;

/**
 * @brief Média de stockage.
 */
typedef enum { CHS = 0, LBA = 1 } MultibootInfoDriveMode;
typedef struct MultibootInfoDrive {
    uint32 size;
    
    uint8 driveNumber;
    
    /* Cela permet-il de contraindre la taille d'un enum ? */
    MultibootInfoDriveMode driveMode:8;
    
    
    uint16 driveCylinders;
    uint8 driveHeads;
    uint8 driveSectors;
    
    /* Et comment je gère cette horreur moi ? */
    uint16 drivePorts;
} PACKED MultibootInfoDrive;

/**
 * @brief Fonction GET CONFIGURATION du BIOS.
 */
typedef struct MultibootInfoConfigTable {
    /* Chercher le format de retour de l'appel au BIOS nommé
     * GET CONFIGURATION */
} PACKED MultibootInfoConfigTable;

/**
 * @brief Advanced Power Management.
 */
typedef struct MultibootInfoApmTable {
    /* Voir le standard apm pour les types...
     * http://www.micr.../hwdev/busbios/amp_12.htm
     * Soit dit en passant, sympa la référence à micr... dans un
     * standard libre (très mal écrit le standard au fait...) */
    uint16 version;
    uint16 cseg;
    uint32 offset;
    uint16 cseg16;
    uint16 dseg;
    uint16 flags;
    uint16 csegLen;
    uint16 cseg16Len;
    uint16 dsegLen;    
} PACKED MultibootInfoApmTable;

/**
 * @brief Contrôleur VESA Bios Extension
 */
typedef struct MultibootInfoVbeControllerInfo{
    char signature[4];		    /* == "VESA" */
    union {
	    uint16 version;
	    struct {
	        uint8 versionMajeure;   /* 2 pour VBE 2.* */
	        uint8 versionMineure;   /* 0 pour VBE *.0 */
	    };
    };
	/* pointeurLointain ??? */
    uint16 oemString[2];	/* Nom du périphérique, donné par le constructeur */
    uint32 capabilities;	/* Fonctionnalités offertes */
	/* pointeurLointain ??? */
    uint16 videomodes[2];	/* Liste de modes vidéo */
    uint16 totalMemory;	/* nombre de blocs de 64ko */
} PACKED MultibootInfoVbeControllerInfo;

/**
 * @brief Mode vidéo VESA Bios Extension
 */
typedef struct MultibootInfoVbeModeInfo {
    uint16 attributes;
    uint8 winA,winB;
    uint16 granularity;
    uint16 winsize;
    uint16 segmentA, segmentB;
    pointeurLointain winFunc;
    uint16 pitch;                    /* octets par scanline */
    
    uint16 Xres, Yres;
    uint8 Wchar, Ychar, planes, bpp, banks;
    uint8 memory_model, bank_size, image_pages;
    uint8 reserved;
    
    struct {
	uint8 maskSize;
	uint8 fieldPos;
    } red, green, blue, reservedChannel;
    uint8 directcolor_attributes;
    
    void* linearAddress;                /* L'adresse du framebuffer linéaire :) */
    void* offscreenAddress;
    uint16 offscreenSizeKB;
} PACKED MultibootInfoVbeModeInfo;

/**
 * @brief  Informations récupérées par grub
 */
typedef struct MultibootInfo {
    MultibootInfoFlags flags;
    
    uint32 memLower;
    uint32 memUpper;
    
    MultibootInfoBootDevice bootDevice;
    
    StringZ cmdline;
    
    uint32 modsCount;
    MultibootInfoModule* modsAddr;
    
    union {
        MultibootInfoAout aout;
        MultibootInfoElf elf;
    } PACKED syms;
    
    uint32 mmapLength;
    MultibootInfoMmap* mmapAddr;
    
    uint32 drivesLength;
    MultibootInfoDrive* drivesAddr;
    
    MultibootInfoConfigTable* configTable;
    
    StringZ bootLoaderName;
    
    MultibootInfoApmTable* apmTable;
    
    MultibootInfoVbeControllerInfo* vbeControlInfo;
    MultibootInfoVbeModeInfo* vbeModeInfo;
    uint16 vbeMode;
    uint16 vbeInterfaceSeg;
    uint16 vbeInterfaceOff;
    uint16 vbeInterfaceLen;
} PACKED MultibootInfo;

typedef struct EtatMultiboot {
	MultibootInfo* InfoMultiboot;
	uint32 magicMultiboot;
} EtatMultiboot;

#endif
